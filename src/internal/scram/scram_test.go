// FILE: src/internal/scram/scram_test.go
package scram

import (
	"crypto/rand"
	"encoding/base64"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"golang.org/x/crypto/argon2"
)

func TestCredentialDerivation(t *testing.T) {
	salt := make([]byte, 16)
	_, err := rand.Read(salt)
	require.NoError(t, err)

	cred, err := DeriveCredential("testuser", "testpass123", salt, 3, 64*1024, 4)
	require.NoError(t, err)

	assert.Equal(t, "testuser", cred.Username)
	assert.Equal(t, uint32(3), cred.ArgonTime)
	assert.Equal(t, uint32(64*1024), cred.ArgonMemory)
	assert.Equal(t, uint8(4), cred.ArgonThreads)
	assert.Len(t, cred.StoredKey, 32)
	assert.Len(t, cred.ServerKey, 32)
}

func TestFullHandshake(t *testing.T) {
	// Setup server with credential
	server := NewServer()
	salt := make([]byte, 16)
	_, err := rand.Read(salt)
	require.NoError(t, err)

	cred, err := DeriveCredential("alice", "secret123", salt, 3, 64*1024, 4)
	require.NoError(t, err)
	server.AddCredential(cred)

	// Setup client
	client := NewClient("alice", "secret123")

	// Step 1: Client starts
	clientFirst, err := client.StartAuthentication()
	require.NoError(t, err)
	assert.Equal(t, "alice", clientFirst.Username)
	assert.NotEmpty(t, clientFirst.ClientNonce)

	// Step 2: Server responds
	serverFirst, err := server.HandleClientFirst(clientFirst)
	require.NoError(t, err)
	assert.Contains(t, serverFirst.FullNonce, clientFirst.ClientNonce)
	assert.Equal(t, base64.StdEncoding.EncodeToString(salt), serverFirst.Salt)

	// Step 3: Client proves
	clientFinal, err := client.ProcessServerFirst(serverFirst)
	require.NoError(t, err)
	assert.Equal(t, serverFirst.FullNonce, clientFinal.FullNonce)
	assert.NotEmpty(t, clientFinal.ClientProof)

	// Step 4: Server verifies and signs
	serverFinal, err := server.HandleClientFinal(clientFinal)
	require.NoError(t, err)
	assert.NotEmpty(t, serverFinal.ServerSignature)
	assert.NotEmpty(t, serverFinal.SessionID)

	// Step 5: Client verifies server
	err = client.VerifyServerFinal(serverFinal)
	assert.NoError(t, err)
}

func TestInvalidPassword(t *testing.T) {
	server := NewServer()
	salt := make([]byte, 16)
	rand.Read(salt)

	cred, _ := DeriveCredential("bob", "correct", salt, 3, 64*1024, 4)
	server.AddCredential(cred)

	// Client with wrong password
	client := NewClient("bob", "wrong")

	clientFirst, _ := client.StartAuthentication()
	serverFirst, _ := server.HandleClientFirst(clientFirst)
	clientFinal, _ := client.ProcessServerFirst(serverFirst)

	clientFinal, err := client.ProcessServerFirst(serverFirst)
	require.NoError(t, err) // Check error to prevent panic

	// Server should reject
	_, err = server.HandleClientFinal(clientFinal)
	assert.Error(t, err)
	assert.Contains(t, err.Error(), "authentication failed")
}

func TestHandshakeTimeout(t *testing.T) {
	server := NewServer()
	salt := make([]byte, 16)
	rand.Read(salt)

	cred, _ := DeriveCredential("charlie", "pass", salt, 3, 64*1024, 4)
	server.AddCredential(cred)

	client := NewClient("charlie", "pass")
	clientFirst, _ := client.StartAuthentication()
	serverFirst, _ := server.HandleClientFirst(clientFirst)

	// Manipulate handshake timestamp
	server.mu.Lock()
	if state, exists := server.handshakes[serverFirst.FullNonce]; exists {
		state.CreatedAt = time.Now().Add(-61 * time.Second)
	}
	server.mu.Unlock()

	clientFinal, _ := client.ProcessServerFirst(serverFirst)
	_, err := server.HandleClientFinal(clientFinal)

	assert.Error(t, err)
	assert.Contains(t, err.Error(), "timeout")
}

func TestMessageParsing(t *testing.T) {
	// Test ClientFirst parsing
	cf, err := ParseClientFirst("u=alice,n=abc123")
	require.NoError(t, err)
	assert.Equal(t, "alice", cf.Username)
	assert.Equal(t, "abc123", cf.ClientNonce)

	// Test marshal round-trip
	marshaled := cf.Marshal()
	parsed, err := ParseClientFirst(marshaled)
	require.NoError(t, err)
	assert.Equal(t, cf.Username, parsed.Username)
	assert.Equal(t, cf.ClientNonce, parsed.ClientNonce)
}

func TestPHCMigration(t *testing.T) {
	// Create PHC hash using known values
	password := "testpass"
	salt := []byte("saltsaltsaltsalt")
	saltB64 := base64.RawStdEncoding.EncodeToString(salt)

	// This would be generated by the existing auth system
	phcHash := "$argon2id$v=19$m=65536,t=3,p=4$" + saltB64 + "$" + "dGVzdGhhc2g" // dummy hash

	// For testing, we need a valid hash - generate it
	hash := argon2.IDKey([]byte(password), salt, 3, 65536, 4, 32)
	hashB64 := base64.RawStdEncoding.EncodeToString(hash)
	phcHash = "$argon2id$v=19$m=65536,t=3,p=4$" + saltB64 + "$" + hashB64

	cred, err := MigrateFromPHC("alice", password, phcHash)
	require.NoError(t, err)
	assert.Equal(t, "alice", cred.Username)
	assert.Equal(t, salt, cred.Salt)
}

func TestRateLimiting(t *testing.T) {
	manager := NewScramManager()

	limiter := manager.GetRateLimiter("192.168.1.1")

	// Should allow burst
	for i := 0; i < 3; i++ {
		assert.True(t, limiter.Allow())
	}

	// 4th should be rate limited
	assert.False(t, limiter.Allow())
}

func TestNonceUniqueness(t *testing.T) {
	nonces := make(map[string]bool)

	for i := 0; i < 1000; i++ {
		nonce := generateNonce()
		assert.False(t, nonces[nonce], "Duplicate nonce generated")
		nonces[nonce] = true
	}
}

func TestConstantTimeComparison(t *testing.T) {
	server := NewServer()
	salt := make([]byte, 16)
	rand.Read(salt)

	// Add real user
	cred, _ := DeriveCredential("realuser", "realpass", salt, 3, 64*1024, 4)
	server.AddCredential(cred)

	// Test timing independence for invalid user
	fakeClient := NewClient("fakeuser", "fakepass")
	clientFirst, _ := fakeClient.StartAuthentication()

	// Should still return ServerFirst (no user enumeration)
	serverFirst, err := server.HandleClientFirst(clientFirst)
	assert.NotNil(t, serverFirst)
	assert.Error(t, err) // Internal error, not exposed to client
}

func BenchmarkArgon2Derivation(b *testing.B) {
	salt := make([]byte, 16)
	rand.Read(salt)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		DeriveCredential("user", "password", salt, 3, 64*1024, 4)
	}
}

func BenchmarkFullHandshake(b *testing.B) {
	server := NewServer()
	salt := make([]byte, 16)
	rand.Read(salt)
	cred, _ := DeriveCredential("bench", "pass", salt, 3, 64*1024, 4)
	server.AddCredential(cred)

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		client := NewClient("bench", "pass")
		clientFirst, _ := client.StartAuthentication()
		serverFirst, _ := server.HandleClientFirst(clientFirst)
		clientFinal, _ := client.ProcessServerFirst(serverFirst)
		serverFinal, _ := server.HandleClientFinal(clientFinal)
		client.VerifyServerFinal(serverFinal)
	}
}